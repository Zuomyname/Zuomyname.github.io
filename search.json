[{"title":"CentOs 7 下安装 wkhtmltopdf","url":"/2021/05/06/centos7-%E4%B8%8B%E5%AE%89%E8%A3%85-wkhtmltopdf/","content":"两种方式安装，其中方法一比较顺利方法一\n安装依赖yum install -y fontconfig libX11 libXext libXrender libjpeg libpng xorg-x11-fonts-75dpi xorg-x11-fonts-Type1\n\n\n下载 wkhtmltopdfwget https://github.com/wkhtmltopdf/packaging/releases/download/0.12.6-1/wkhtmltox-0.12.6-1.centos7.x86_64.rpm\n\n\n解压 wkhtmltopdfrpm -ivh wkhtmltox-0.12.6-1.centos7.x86_64.rpm\n\n\n查看 wkhtmltopdfwhereis wkhtmltopdf\n\n\n\n方法二：在 laravel 项目中使用 composer 安装\ncomposer 安装\n$ composer require h4cc/wkhtmltopdf-amd64 0.12.x\n$ composer require h4cc/wkhtmltoimage-amd64 0.12.x\n\n\n接下来将安装好的 wkhtmltopdf 复制到 Linux 系统可执行命令的目录中\ncp vendor/h4cc/wkhtmltoimage-amd64/bin/wkhtmltoimage-amd64 /usr/local/bin/\ncp vendor/h4cc/wkhtmltopdf-amd64/bin/wkhtmltopdf-amd64 /usr/local/bin/\n//并使其可执行：\nchmod +x /usr/local/bin/wkhtmltoimage-amd64 \nchmod +x /usr/local/bin/wkhtmltopdf-amd64\n\n\n\n可能存在的问题\n中文字体无法显示// 下载 windows 宋体字体，将 simsunbd.ttf 文件导入到 centos 系统 /usr/share/fonts/chinese/TrueType 文件目录下\n\n\n\n","tags":["wkhtmltopdf"]},{"title":"Composer required 内存溢出解决办法","url":"/2021/05/06/composer-required-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","content":"在使用 composer 过程中出现内存溢出错误，只需要暂时将内存设置为没有限制COMPOSER_MEMORY_LIMIT=-1 composer required(install、update)\n\n","tags":["Composer"]},{"title":"Elasticsearch 基础操作","url":"/2021/05/17/es-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/","content":"查询\n条件查询\n\nGET news202010/_search\n&#123;\n &quot;query&quot;: &#123;\n   &quot;match&quot;: &#123;\n     &quot;textSrc&quot;: &quot;海底捞&quot;\n   &#125;\n &#125;\n&#125;\n\n\n字段过滤\n\nGET news202010/_search\n&#123;\n &quot;query&quot;: &#123;\n   &quot;match&quot;: &#123;\n     &quot;textSrc&quot;: &quot;海底捞&quot;\n   &#125;\n &#125;,\n &quot;_source&quot;: [&quot;mediaTname&quot;]\n&#125;\n\n\n排序\n\nGET news202010/_search\n&#123;\n &quot;query&quot;: &#123;\n   &quot;match&quot;: &#123;\n     &quot;textSrc&quot;: &quot;海底捞&quot;\n   &#125;\n &#125;,\n &quot;sort&quot;: [\n   &#123;\n     &quot;pubtime&quot;://字段 &#123;\n       &quot;order&quot;: &quot;desc&quot;\n     &#125;\n   &#125;\n ]\n&#125;\n\n\n分页\n\nGET news202010/_search\n&#123;\n &quot;query&quot;: &#123;\n   &quot;match&quot;: &#123;\n     &quot;textSrc&quot;: &quot;海底捞&quot;\n   &#125;\n &#125;,\n &quot;sort&quot;: [\n   &#123;\n     &quot;pubtime&quot;: &#123;\n       &quot;order&quot;: &quot;desc&quot;\n     &#125;\n   &#125;\n ],\n &quot;from&quot;: 0,\n &quot;size&quot;: 20\n&#125;\n\n\n多条件查询\n\nGET news202010/_search\n&#123;\n &quot;query&quot;: &#123;\n   &quot;bool&quot;: &#123;\n     &quot;must&quot;: [\n       &#123;\n         &quot;match&quot;: &#123;\n           &quot;mediaNameSrc&quot;: &quot;搜狐&quot;\n         &#125;\n       &#125;,\n       &#123;\n         &quot;match&quot;: &#123;\n          li &quot;countryName&quot;: &quot;中国&quot;\n         &#125;\n       &#125;\n     ]\n   &#125;\n &#125;\n&#125;\n// must 相当于 mysql 中 where id = 1 and name=xxx\n// should 相当于 or\n\n","tags":["Elasticsearch"]},{"title":"Laravel passport OAuth 认证使用","url":"/2021/05/17/laravel-passport-OAuth-%E8%AE%A4%E8%AF%81%E4%BD%BF%E7%94%A8/","content":"安装扩展包composer require laravel/passport\n\n数据库迁移php artisan migrate\n\n安装 Passportphp artisan passport:install\n\n在用户模型类中使用 HasApiTokens Trait// 在 User Model 中\nuse HasApiTokens;\n\n在 AuthServiceProvider 中注册 Passport 路由public function boot()\n&#123;\n    $this-&gt;registerPolicies();\n\n    Passport::routes();// 这里增加\n&#125;\n\n设置 Passport 在输入 API 请求中使用// 位置 =&gt; config/auth.php\n&#39;api&#39; =&gt; [\n       &#39;driver&#39; =&gt; &#39;passport&#39;, // 这里是修改的\n       &#39;provider&#39; =&gt; &#39;users&#39;,\n],\n\n从 Web 浏览器访问认证 API// 先要在 Http\\Kernel.php 的 $middlewareGroups 属性中新增中间件 CreateFreshApiToken\n\nprotected $middlewareGroups = [\n    &#39;web&#39; =&gt; [\n        \\App\\Http\\Middleware\\EncryptCookies::class,\n        \\Illuminate\\Cookie\\Middleware\\AddQueuedCookiesToResponse::class,\n        \\Illuminate\\Session\\Middleware\\StartSession::class,\n        // \\Illuminate\\Session\\Middleware\\AuthenticateSession::class,\n        \\Illuminate\\View\\Middleware\\ShareErrorsFromSession::class,\n        \\App\\Http\\Middleware\\VerifyCsrfToken::class,\n        \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,\n        CreateFreshApiToken::class // 这里是增加的\n    ],\n\n    &#39;api&#39; =&gt; [\n        &#39;throttle:60,1&#39;,\n        &#39;bindings&#39;,\n    ],\n];\n\n在 api.php 中使用Route::prefix(&#39;v1&#39;)\n    -&gt;middleware(&#39;auth:api&#39;)\n    -&gt;group(function () &#123;\n        Route::get(&#39;/user&#39;, function (Request $request) &#123;\n           return $request-&gt;user();\n        &#125;);\n    &#125;);\n\n","tags":["Laravel"]},{"title":"Laravel 解决跨域","url":"/2021/04/30/laravel-%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F/","content":"1. 安装扩展composer require barryvdh/laravel-cors\n\n2. 发布配置文件php artisan vendor:publish --provider=&quot;Barryvdh\\Cors\\ServiceProvider&quot;\n\n3. 使用如果需要全局使用，可以在 app/Http/Kernel.php 的 $middleware 中增加 \\Barryvdh\\Cors\\HandleCors::class，\n\n","categories":["PHP"],"tags":["Laravel"]},{"title":"MySql8 修改密码加密方式","url":"/2021/05/06/mysql8-%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F/","content":"进入my.cnf 修改配置文件vim /etc/my.cnf\n[mysqld]\ndefault_authentication_plugin=mysql_native_password\n\n进入 mysql 修改配置ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;密码&#39; PASSWORD EXPIRE NEVER;\nALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;密码&#39;; \nFLUSH PRIVILEGES;\n\n查看加密方式是否被改变use mysql;\nselect user,plugin from user;\n// 如果出现两个root用户且加密方式不对，删除不是mysql_native_password的一个\n\n","tags":["MySql"]},{"title":"MySql8 远程连接方式","url":"/2021/05/06/mysql8_%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F/","content":"mysql8 默认配置是不开启远程连接的，这里我们需要修改 mysql 数据库的配置来主动开启\nmysql -uroot -p\nuse mysql;\nselect host,user from user;\nupdate user set host=&#39;%&#39; where user=root;\n// 更新数据库\nflush privileges;\n\n然后就可以远程登录了\n","tags":["MySql"]},{"title":"vue-cli 初始化原型项目","url":"/2021/04/30/vue-cli-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8E%9F%E5%9E%8B%E9%A1%B9%E7%9B%AE/","content":"安装 vue-clinpm install -g @vue/cli\n\n初始化项目vue create project\n\n启动项目cd project\nnpm run serve\n\n需要安装的依赖vue add vue-router\n\n","tags":["Vue"]},{"title":"wsl2安装node工具","url":"/2021/05/17/wsl2%E5%AE%89%E8%A3%85node%E5%B7%A5%E5%85%B7/","content":"安装 curlsudo apt-get install curl\n\n安装 nvmnvm：curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/*/install.sh | bash\n// 版本可以参照最新的 nvm 版本 [nvm github](https://github.com/nvm-sh/nvm)\n\n安装 node LTS 版本nvm install node --lts\n\n查看nvmnvm ls\n\n","tags":["wsl2"]},{"title":"连接 docker mysql 容器","url":"/2021/05/06/%E8%BF%9E%E6%8E%A5-docker-mysql-%E5%AE%B9%E5%99%A8/","content":"创建新 mysql 容器docker pull mysql\n\n启动 mysql 容器sudo docker run -p 63306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=root -d mysql\n// 将容器的 3306 端口映射到主机的 63306 端口，密码为root\n\n进入mysql容器docker exec -it mysql bash\n\n在主机连接容器mysql -uroot -proot -P63306 -h127.0.0.1\n\n","tags":["Docker"]},{"title":"Docker 学习","url":"/2021/05/06/docker-%E5%AD%A6%E4%B9%A0/","content":"Docker 概述1. docker 为什么会出现\n环境不统一\n环境配置十分麻烦，部署费时费力\ndocker 的思想来源于集装箱\ndocker 通过隔离机制，可以将服务器利用到极致\n\n2. docker 可以做什么容器化技术不是模拟一个完整的操作系统\n比较 docker 和传统的虚拟技术的不同：\n\n传统虚拟机，虚拟出一个硬件，运行一个完整的操作系统，然后在这个系统上面安装运行软件\n容器内的应用直接运行在宿主机的内容，容器没有自己的内核，也没有虚拟我们的硬件，所以轻便\n每个容器间相互隔离，每个容器内部都有一个属于自己的文件系统，互不影响\n\nDevOps（开发、运维）\n\n应用更快捷的交付和部署\n\n更便捷的升级和扩缩容\n\n更简单的系统运维\n在容器化之后，我们的开发，测试环境都是高度的一致\n\n更高效的计算资源利用\ndocker 是内核级别的虚拟化，可以在一个物理机上运行很多的容器实例。服务器性能可以被压榨到极致\n\n\nDocker 安装1. Docker 的基本组成![image-20200716140943286](/Users/zyyt/Library/Application Support/typora-user-images/image-20200716140943286.png)\n镜像（image）：docker 镜像就好比一个模板，可以通过这个模板创建容器服务，通过镜像可以创建多个容器（最终项目运行在容器中）\n容器（container）：利用容器技术，可以独立运行一个或者一组应用，通过镜像来创建\n启动、停止、删除等基本命令（可以理解为一个简易的linux系统）\n仓库（repository）：存放镜像的地方；分为公有仓库和私有仓库\ndocker hub（默认是国外的）\n安装 docker\ndocker run的流程\n\n开始，docker 在本机寻找镜像，判断本机是否有镜像\n有，运行这个镜像；否，去docker hub 上下载\n在docker hub 上是否能找到这个镜像，找不到就返回错误\n下载镜像到本地，运行这个镜像\n\n底层原理\ndocker 是怎么工作的\n\ndocker 是一个 client-server结构的系统，docker的守护进程运行在主机，通过 socket从客户端访问\ndockerserver 接受到 docker-client的指令，执行命令\n\ndocker 为什么比虚拟机快\n\ndocker有比虚拟机更少的抽象层\ndocker 利用的是宿主机的内核，虚拟机需要 guest os\n新建一个容器的时候，docker 不需要像虚拟机重新加载一个操作系统内核，避免引导，虚拟机需要加载一个 guest os\n\nDocker 命令\n帮助命令\ndocker version # 显示 docker 的版本信息\ndocker info # 显示 docker 的系统信息，包括系统镜像和数量\ndocker help \n\n\n镜像命令\ndocker images # 查看主机上的所有镜像\n[root@iZ8vbcrus31oj3y0u2w3svZ ~]# docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nhello-world         latest              bf756fb1ae65        6 months ago        13.3kB\n\n#解释\nREPOSITORY 镜像的仓库源\nTAG                 镜像的标签\nIMAGE ID     镜像的ID\nCREATED         镜像的创建时间\nSIZE             镜像的大小\n\n# 可选项\nOptions:\n  -a              显示所有镜像\n  -q             只显示镜像的 ID\n\ndocker search # 搜索镜像\n[root@iZ8vbcrus31oj3y0u2w3svZ ~]# docker search mysql\nNAME                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED\nmysql                             MySQL is a widely used, open-source relation…   9735                [OK]\nmariadb                           MariaDB is a community-developed fork of MyS…   3552                [OK]\n\n# 可选项\n--filter=start=3000 # 表示搜索收藏大于 3000 的镜像\n\ndocker pull # 下载镜像\n# 下载镜像 docker pull 镜像名称[:tag]\n[root@iZ8vbcrus31oj3y0u2w3svZ ~]# docker pull mysql\nUsing default tag: latest # 如果不写 tag，默认下载最新的 tag\nlatest: Pulling from library/mysql\n8559a31e96f4: Pull complete # 分成下载，docker image 的核心，联合文件系统\nd51ce1c2e575: Pull complete\nc2344adc4858: Pull complete\nfcf3ceff18fc: Pull complete\n16da0c38dc5b: Pull complete\nb905d1797e97: Pull complete\n4b50d1c6b05c: Pull complete\n571e8a282156: Pull complete\ne7cc823c6090: Pull complete\n61161ba7d2fc: Pull complete\n74f29f825aaf: Pull complete\nd29992fd199f: Pull complete\nDigest: sha256:fe0a5b418ecf9b450d0e59062312b488d4d4ea98fc81427e3704f85154ee859c # 签名信息\nStatus: Downloaded newer image for mysql:latest\ndocker.io/library/mysql:latest # 真实地址 == docker pull docker.io/library/mysql:latest\n\ndocker rmi # 删除镜像\ndocker rmi -f 容器id # 按id 删除镜像\ndocker rmi -f $(docker images -aq) # 删除全部镜像\n\n\n容器命令\n\n新建容器并启动\ndocker run[可选参数] image\n\n# 参数说明\n-name=&quot;Name&quot;     容器名称，用来区分容器\n-d                         后台方式运行\n-it                     使用交互方式运行，进入容器查看内容\n-p                         指定容器的端口 -p8080:8080\n-P dap               随机映射端口\n    \n# 测试\n[root@iZ8vbcrus31oj3y0u2w3svZ ~]# docker run -it centos\n[root@ca30f0ae3fd6 /]# ls\nbin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var\n\n\n列出所有运行的容器\n# 正在运行的容器\n[root@iZ8vbcrus31oj3y0u2w3svZ /]# docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n# 查看之前运行过的容器\n[root@iZ8vbcrus31oj3y0u2w3svZ /]# docker ps -a\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                          PORTS               NAMES\nca30f0ae3fd6        centos              &quot;/bin/bash&quot;         2 minutes ago       Exited (0) About a minute ago                       compassionate_engelbart\n0ec2b1b3f3be        centos              &quot;/bin/bash&quot;         4 minutes ago       Exited (0) 4 minutes ago                            kind_ishizaka\nb9045bad84a7        bf756fb1ae65        &quot;/hello&quot;            3 hours ago         Exited (0) 3 hours ago                              trusting_payne\n\n-n 显示最近创建的容器\n-q 只显示容器的编号\n\n\n删除容器\ndocker rm 容器 id # 删除指定的容器，不能删除正在运行的容器，如果要强制删除 rm -f\ndocker rm -f $(docker ps -aq) # 删除所有的容器\ndocker ps -a -q | xargs rm # 删除所有容器\n\n\n退出容器\nexit # 停止容器并退出\n\n\n启动和停止容器的操作\ndocker start 容器id             #启动容器\ndocker restart 容器id            #重启容器\ndocker stop 容器id                #停止当前正在运行的容器\ndocker kill 容器id                # 强制停止的当前容器\n\n\n\n\n常用的其他命令\n\n后台启动\ndocker run -d 镜像名称\n\n# 常见的坑，docker 容器使用后台运行，就必须要有个前台进程，docker 发现没有应用，就会自动停止\n# nginx 容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了\n\n\n查看日志\ndocker logs -f -t --tail 10 容器id #显示指定行数的日志\ndocker logs -f -t 容器id # 显示全部的日志\n\n\n查看容器中的进程信息\ndocker top 容器id \n\n\n查看元数据\ndocker inspect 容器id\n\n\n进入当前正在运行的容器\n# 我们容器通常是使用后台方式运行的，现在需要进入容器\n# 命令\ndocker exec 容器id # 进入容器后，开启一个新的终端，可以在里面操作（常用）\ndocker arrach 容器 id #进入容器正在执行的终端，不会启动新的进程\n\n\n从容器中拷贝文件到主机上\ndocker cp 容器id:容器内路径 目的地路径\n\n# 测试\n[root@iZ8vbcrus31oj3y0u2w3svZ home]# ll\n总用量 4\ndrwx------ 2 www www 4096 3月  24 22:04 www\n[root@iZ8vbcrus31oj3y0u2w3svZ home]# docker ps -a\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n[root@iZ8vbcrus31oj3y0u2w3svZ home]# docker run -it centos\n[root@753e672d39fd /]# cd /home\n[root@753e672d39fd home]# touch test.java\n[root@753e672d39fd home]# exit\nexit\n[root@iZ8vbcrus31oj3y0u2w3svZ home]# docker ps -a\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES\n753e672d39fd        centos              &quot;/bin/bash&quot;         23 seconds ago      Exited (0) 7 seconds ago                       relaxed_gould\n[root@iZ8vbcrus31oj3y0u2w3svZ home]# docker cp 753e672d39fd:/home/test.java /home\n[root@iZ8vbcrus31oj3y0u2w3svZ home]# ll\n总用量 4\n-rw-r--r-- 1 root root    0 7月  16 18:15 test.java\ndrwx------ 2 www  www  4096 3月  24 22:04 www\n[root@iZ8vbcrus31oj3y0u2w3svZ home]#\n\n\n常用命令小结\nattach             # 当前 shell 下，attach 链接指定运行镜像\nbuild             # 通过 Dockerfile 定制镜像\ncommit             # 提交当前容器为新的镜像\ncp                     # 从容器中拷贝指定文件或者目录到宿主机中\ncreate             # 创建一个新的容器，同 run ，但不启动容器\ndiff                 # 查看 docker 容器的变化\nevents             # 从docker 服务获取容器实时时间\nexec                 # 在已存在的容器上运行命令\nexport             # 到处容器的内容流作为一个 tar 归档文件\nhistory         # 展示一个镜像形成历史\nimages             # 列出系统当前镜像\nimport             # 从 tar 包中的内容创建一个新的而文件系统镜像\ninfo                 # 显示系统相关信息\ninspect         # 查看容器详细信息\nkill                 # kill 指定 docker 容器\nload                 # 从一个 tar 包中加载一个镜像\nlogin             # 注册或者登陆一个 docker 源服务器\nlogout             # 从当前源登出\nlogs                 # 查看当前容器日志信息\nport                 # 查看映射端口对应的容器内部源端口\npause             # 暂停容器\nps                     # 列出容器列表\npull                 # 从docker 镜像源服务器拉去指定镜像\npush                 # 推送指定镜像或者库镜像只 docker源服务器\nrestart         # 重启运行的容器\nrm                     # 删除一个或者多个容器\nrmi                 # 移除一个或者多个镜像\nrun                 # 创建一个新的容器并运行一个命令\nsave                 # 保存一个镜像为一个 tar 包（对应 load）\nsearch             # 在docker hub 中搜索镜像\nstart             # 启动容器\nstop                 # 停止容器\ntag                 # 给源中镜像打标签\ntop                 # 查看容器中运行的进程\nunpause         # 取消暂停容器\nversion         # 查看 docker 版本信息\nwait                 # 截取容器停止时退出状态值\n\n\n安装 nginx\n# 1. 下载nginx镜像\ndocker search nginx\ndocker pull nginx\n\n# 2. 运行容器\ndocker run -d --name nginx01 -p 3344:80 nginx\n\n# 3. 进入容器\ndocker exec -it nginx01 /bin/bash\n\n\n安装 es\ndocker run -d --name elasticsearch  -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:7.6.2\n\n#-e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; 限制内存大小\n\n[root@iZ8vbcrus31oj3y0u2w3svZ ~]# curl localhost:9200\n&#123;\n  &quot;name&quot; : &quot;ff85ed481a48&quot;,\n  &quot;cluster_name&quot; : &quot;docker-cluster&quot;,\n  &quot;cluster_uuid&quot; : &quot;FVGcHuJJTlaOr97RmCdJEQ&quot;,\n  &quot;version&quot; : &#123;\n    &quot;number&quot; : &quot;7.6.2&quot;,\n    &quot;build_flavor&quot; : &quot;default&quot;,\n    &quot;build_type&quot; : &quot;docker&quot;,\n    &quot;build_hash&quot; : &quot;ef48eb35cf30adf4db14086e8aabd07ef6fb113f&quot;,\n    &quot;build_date&quot; : &quot;2020-03-26T06:34:37.794943Z&quot;,\n    &quot;build_snapshot&quot; : false,\n    &quot;lucene_version&quot; : &quot;8.4.0&quot;,\n    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,\n    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;\n  &#125;,\n  &quot;tagline&quot; : &quot;You Know, for Search&quot;\n&#125;\n\n# 查看内存使用情况\ndocker stats 容器id\n\n\n使用 kibana 连接 elasticsearch\n通过 linux 内网地址来进行连接；涉及到 docker 的网络原理\n\n\n\n可视化\n\nportainer ，docker 的图形化管理工具，提供一个后台面板供我们操作\n\n\n\nDocker 镜像镜像是什么\n所有的应用，直接打包 docker 镜像，就可以直接跑起来\n如何得到镜像：\n\n从远程仓库下载\n自己制作\n别人给\n\ndocker 镜像加载原理 \n联合文件系统\n分层下载\nCommit 镜像docker commit 提交容器成为一个新的副本\ndocker commit -m=&#39;提交的描述信息&#39; -a=&#39;作者&#39; 容器 id 目标镜像名称;[tag]\n\n容器数据卷什么是容器数据卷：需要数据可以持久化，容器之间可以有一个数据共享的技术，docker 产生的数据，同步到本地，就是将容器内的目录挂在在 Linux 上面\n容器的持久化和同步操作，容器间也是可以数据共享的\n使用数据卷\n\n使用命令来挂载\ndocker run -it -v 主机目录：容器内目录\n\n\n具名挂载和匿名挂载\n# 匿名挂载 -v 的时候只写了容器内的路径\n-v 容器内录路径\ndocker rn -d -p -v /etc/nginx nginx\n\n# 查看所有卷的情况\ndocker volume ls\n\n# 具名挂载\ndocker rn -d -p -v jump-nginx:/etc/nginx nginx\n\n[root@iZ8vbcrus31oj3y0u2w3svZ ~]# docker volume ls\nDRIVER              VOLUME NAME\nlocal               jump-nginx\n\n# 查看卷详细信息\ndocker volume inspect jump-nginx\n\n[root@iZ8vbcrus31oj3y0u2w3svZ ~]# docker volume inspect jump-nginx\n[\n    &#123;\n        &quot;CreatedAt&quot;: &quot;2020-07-17T15:52:03+08:00&quot;,\n        &quot;Driver&quot;: &quot;local&quot;,\n        &quot;Labels&quot;: null,\n        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/jump-nginx/_data&quot;,\n        &quot;Name&quot;: &quot;jump-nginx&quot;,\n        &quot;Options&quot;: null,\n        &quot;Scope&quot;: &quot;local&quot;\n    &#125;\n]\n\n# 指定路径挂载\ndocker rn -d -p -v /宿主机地址:/etc/nginx nginx\n\n# 在没有指定目录情况下，默认路径在 /var/lib/docker/volumes/xxx/_data\n\ndocker rn -d -p -v jump-nginx:/etc/nginx:ro nginx\ndocker rn -d -p -v jump-nginx:/etc/nginx:rw nginx\n\n# ro rw 改变读写权限\nro readonly 只读，说明这个路径只能通过宿主机来操作，在容器内部无法操作\nrw readwrite 可读可写\n\n# 一旦设置了容器的权限，容器对我们挂载出来的内容就有限定了\n\n\n\nDocker File就是用来构建docker 镜像的构建文件，命令脚本，通过这个脚本可以生成一个镜像，脚本就是一个个的命令，每个命令都是一层\nFROM centos\n\nVOLUME [&quot;volume01&quot;, &quot;volume02&quot;]\n\nCMD echo &quot;++++++ end +++++&quot;\nCMD /bin/bash\n\ndocker build dockerfile\n\nDockerfile 的构建过程基础知识：\n\n每个保留关键字（指令）都必须是大写字母\n执行从上到小顺序执行\n#表示注释\n每个指令都会创建提交一个新的镜像层，并提交\n\ndockerfile 是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile 文件，这个文件十分简单\ndocker 镜像逐渐成为企业交付的标准，必须要掌握\n步骤：\nDockerfile：构建文件，定义了一切的步骤，源代码\nDockerImgaes：通过dockerfile构建生成的镜像，最终发布和运行的产品\nDocker容器：容器就是镜像运行起来供服务的\nDockerfile 的一些指令![image-20200720134234025](/Users/zyyt/Library/Application Support/typora-user-images/image-20200720134234025.png)\n![image-20200720134302424](/Users/zyyt/Library/Application Support/typora-user-images/image-20200720134302424.png)\nFROM                     # 基础镜像，一切从这里开始构建\nMAINTAINER         # 镜像是谁写的，姓名+邮箱\nRUN                     # 镜像构建的要运行的命令\nADD                     # 步骤，tomcat 镜像，这个 tomcat 的压缩包，添加内容\nWORDDIR             # 镜像的工作目录\nVOLUME                 # 挂载目录\nEXPOSE                 # 暴露端口有配置 -p\nCMD                     # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代\nENTRYPOINT         # 指定这个容器启动的时候要运行的命令，可以追加命令\nONBUILD             # 当构建一个被继承 dockerfile，这个时候就会运行 ONBUILD的指定 ，出发指令\nCOPY                     # 将我们的文件拷贝到镜像中\nENV                     # 构建的时候设置环境变量\n\n\n创建一个自己的 centos\n\n[root@iZ8vbcrus31oj3y0u2w3svZ dockerfile]# cat mydockerfile-centos\nFROM centos\n\nMAINTAINER will.zuo&lt;17683115201@163.com&gt;\n\nENV MYPATH /usr/local\nWORDDIR $MYPATH\n\nRUN yum -y install vim\nRUN yum -y install net-tools\n\nEXPOSE 80\n\nCMD echo $MYPATH\nCMD echo &quot;+++++++ end ++++++++&quot;\nCMD /bin/bash\n\n# 运行构建文件\ndocker build -f mydockerfile-centos -t mycentos .\n\n# 构建成功返回\nSuccessfully built c54058230aa3\nSuccessfully tagged mycentos:latest\n\n# 查看是否存在镜像\n[root@iZ8vbcrus31oj3y0u2w3svZ dockerfile]# docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nmycentos            latest              c54058230aa3        10 seconds ago      295MB\nwill/centos         1.0                 0237c263acb8        2 days ago          215MB\nwill.tomcat         1.0                 bccad863bff2        2 days ago          652MB\ntomcat              9.0                 df72227b40e1        3 days ago          647MB\ntomcat              latest              df72227b40e1        3 days ago          647MB\nmysql               5.7                 d05c76dbbfcf        6 days ago          448MB\nnginx               latest              0901fa9da894        9 days ago          132MB\ncentos              latest              831691599b88        4 weeks ago         215MB\nelasticsearch       7.6.2               f29a1ee41030        3 months ago        791MB\n\n# 测试运行\n\n对比：之前原生的 centos\n我们之后增加的\n![image-20200720140737677](/Users/zyyt/Library/Application Support/typora-user-images/image-20200720140737677.png)\n\nCMD 和 ENTRYPOINT 的区别\n\n\ncmd 后面的命令会把前面命令覆盖\nentrupoint 命令会直接在后面追加\n\ntomcat 镜像\n\n准备好镜像文件， tomcat 压缩包，jdk压缩包\n编写 dockerfile 文件，官方命名 Dockerfile， build 会自动寻找这个文件，不需要 -f 指定文件\n\n发布镜像docker login -u -p\n\ndocker push 镜像名称\n\n发布到阿里云\n创建命名空间\n创建容器镜像\n本地仓库\n参考官方地址\n\n数据卷容器--volumes-from 继承的容器name\n\n容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止，一旦持久化到本地，这个时候本地数据就不会被删除\nDocker 网络理解 docker0# docker 是怎么处理容器网络访问的\n\n# 创建一个新的 tomcat 容器\ndocker run -d -P --name tomcat01 tomcat\n\n# 查看容器的内部网络地址 ，容器启动会得到  eth0@if55 ip 地址，docker分配\ndocker exec tomcat01 ip addr\n\n[root@iZ8vbcrus31oj3y0u2w3svZ ~]# docker exec tomcat01 ip addr\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n54: eth0@if55: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default\n    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0\n    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0\n       valid_lft forever preferred_lft forever\n       \n# linux 可以ping通 docker 容器内部\n\n\n原理\n\n\n我们每启动一个 docker 容器，docker 都会给 docker 容器分配一个 ip，只要电脑上安装了 docker ，都会有docker0网卡，桥接模式，使用的技术是 evth-pair 技术\n[root@iZ8vbcrus31oj3y0u2w3svZ ~]# ip addr\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000\n    link/ether 00:16:3e:0d:8c:bf brd ff:ff:ff:ff:ff:ff\n    inet 172.26.187.10/20 brd 172.26.191.255 scope global dynamic eth0\n       valid_lft 305183217sec preferred_lft 305183217sec\n3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default\n    link/ether 02:42:ca:12:cd:e5 brd ff:ff:ff:ff:ff:ff\n    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0\n       valid_lft forever preferred_lft forever\n55: veth2fece64@if54: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default\n    link/ether 4e:f4:f1:c4:64:24 brd ff:ff:ff:ff:ff:ff link-netnsid 0\n\n# 我们发现容器带来的网卡，都是一对对的\n# evth-pair 就是一对虚拟设备接口，他们都是成对出现的，一段连接协议，一段彼此相连\n# 正因为有这个特性，eth-pair 充当一个桥梁，连接各种虚拟网络设备\n# \n\n\n启动另一个 tomcat 容器\n\n我们来测试 tomcat01 和 tomcat02 是否能ping通\n[root@iZ8vbcrus31oj3y0u2w3svZ ~]# docker exec -it tomcat02 ping 172.17.0.2\nPING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.\n64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.128 ms\n64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.106 ms\n64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.110 ms\n^C\n--- 172.17.0.2 ping statistics ---\n3 packets transmitted, 3 received, 0% packet loss, time 1000ms\nrtt min/avg/max/mdev = 0.106/0.114/0.128/0.015 ms\n\n# 结论，容器之间是可以相互ping通的，容器都是共用的一个路由器，所有容器不指定网络情况下，都是 docker0路由的，docker 会给我们的容器分批一个默认的可用 ip\n\n\n\n\n小结\n\ndocker 使用的是linux的桥接，宿主机中是一个docker\ndocker 中所有的网络接口都是虚拟的，虚拟转发效率高\n只要容器删除，对应网桥一堆就没了\n–linkdocker run -d -P --name tomcat03 --link tomcat02 tomcat\n\n# 测试\n[root@iZ8vbcrus31oj3y0u2w3svZ ~]# docker exec tomcat03 ping tomcat02\nPING tomcat02 (172.17.0.3) 56(84) bytes of data.\n64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.129 ms\n64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.108 ms\n64 bytes from tomcat02 (172.17.0.3): icmp_seq=3 ttl=64 time=0.110 ms\n\n探究：inspect\n–link ：就是我们在 hosts 匹配里增加了 \n[root@iZ8vbcrus31oj3y0u2w3svZ ~]# docker exec tomcat03 cat /etc/hosts\n127.0.0.1    localhost\n::1    localhost ip6-localhost ip6-loopback\nfe00::0    ip6-localnet\nff00::0    ip6-mcastprefix\nff02::1    ip6-allnodes\nff02::2    ip6-allrouters\n172.17.0.3    tomcat02 1a989e21dfaa\n172.17.0.4    51220b767658\n\n自定义网路# 查看所有 docker 网络\n\n[root@iZ8vbcrus31oj3y0u2w3svZ ~]# docker network ls\nNETWORK ID          NAME                DRIVER              SCOPE\n0c75c9a7bf94        bridge              bridge              local\nffecf92be639        host                host                local\n9b9c16be0510        none                null                local\n\n网络模式：\n\nbridge：桥接（默认，自己创建也是使用桥接）\nnone：不配置网络\nhost：和宿主机共享网络\ncontainer：容器网络连通（少用，局限性很大）\n\n测试\n# 自定义一个网络\ndocker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet\n\n# 通过自定义网络启动容器\ndocker run -d -P --network mynet --name tomcat01 tomcat\n\n# 自定义网络可以通过容器名称来进行网络连通\n\n好处：\n\n不同的集群使用不容的网络，保证集群是安全和健康的\n\n网络连通![image-20200720174733412](/Users/zyyt/Library/Application Support/typora-user-images/image-20200720174733412.png)\n# 将容器连接到自定义网络\ndocker network connect mynet tomcat03\n\n# 将 tomcat03 这个容器放入到 mynet 这个网络中\n[root@iZ8vbcrus31oj3y0u2w3svZ ~]# docker inspect mynet\n[\n    &#123;\n        &quot;Name&quot;: &quot;mynet&quot;,\n        &quot;Id&quot;: &quot;a327bd0d4d5374b14f3abfa95a3a32e164b9305131a99e6847966386285b25c4&quot;,\n        &quot;Created&quot;: &quot;2020-07-20T17:41:12.217307542+08:00&quot;,\n        &quot;Scope&quot;: &quot;local&quot;,\n        &quot;Driver&quot;: &quot;bridge&quot;,\n        &quot;EnableIPv6&quot;: false,\n        &quot;IPAM&quot;: &#123;\n            &quot;Driver&quot;: &quot;default&quot;,\n            &quot;Options&quot;: &#123;&#125;,\n            &quot;Config&quot;: [\n                &#123;\n                    &quot;Subnet&quot;: &quot;192.168.0.0/16&quot;,\n                    &quot;Gateway&quot;: &quot;192.168.0.1&quot;\n                &#125;\n            ]\n        &#125;,\n        &quot;Internal&quot;: false,\n        &quot;Attachable&quot;: false,\n        &quot;Ingress&quot;: false,\n        &quot;ConfigFrom&quot;: &#123;\n            &quot;Network&quot;: &quot;&quot;\n        &#125;,\n        &quot;ConfigOnly&quot;: false,\n        &quot;Containers&quot;: &#123;\n            &quot;01e420d4390278b31030a060fd8aff77d749cbb6794ab085f4d4d9ecf4896613&quot;: &#123;\n                &quot;Name&quot;: &quot;tomcat03&quot;,\n                &quot;EndpointID&quot;: &quot;ab8c1ac0018293aa2f4e28ab94e157e15ec295b610da74dece83535a3c788610&quot;,\n                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:04&quot;,\n                &quot;IPv4Address&quot;: &quot;192.168.0.4/16&quot;,\n                &quot;IPv6Address&quot;: &quot;&quot;\n            &#125;,\n            &quot;9765811f0c13b92fe3aa7e8e13f1ef8c32d124a3f02d2c2183a61154f11f7c80&quot;: &#123;\n                &quot;Name&quot;: &quot;tomcat02&quot;,\n                &quot;EndpointID&quot;: &quot;c231ffef794e3034ca6965f65c67c976475d60ab5f8a60baa58c3f7db61ae7a6&quot;,\n                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:03&quot;,\n                &quot;IPv4Address&quot;: &quot;192.168.0.3/16&quot;,\n                &quot;IPv6Address&quot;: &quot;&quot;\n            &#125;,\n            &quot;aaafbaf9706abb26de1fc30796aec29611343495e4c5422e3c38ed249ddd2e09&quot;: &#123;\n                &quot;Name&quot;: &quot;tomcat01&quot;,\n                &quot;EndpointID&quot;: &quot;d1defe4f0bf4ea1b193413c08fa7a265c68b6c8b0a4e4ea74ba6e1296a9d983b&quot;,\n                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:02&quot;,\n                &quot;IPv4Address&quot;: &quot;192.168.0.2/16&quot;,\n                &quot;IPv6Address&quot;: &quot;&quot;\n            &#125;\n        &#125;,\n        &quot;Options&quot;: &#123;&#125;,\n        &quot;Labels&quot;: &#123;&#125;\n    &#125;\n]\n\n结论：\n\n假设要跨网络操作别人，就需要使用 docker network connect\n\n\n查看 docker 容器 ip 地址docker inspect 容器名称或 id\n\n","tags":["Docker"]},{"title":"面试总结","url":"/2021/05/11/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/","content":"PHPPHP 是什么\nPHP（”PHP:Hypertext Preprocessor”，超文本预处理器），基于服务端创建动态网站的脚本语言\n\nPHP数据类型\n基本类型\n布尔型（boolean）：true 和 false 两个值\n整型（integer）\n浮点型（float）\n字符串（string）\n\n\n复合类型\n数组（array）\n对象（object）\n\n\n特殊类型\n资源（resource）：存放 PHP 外部数据，比如数据库、文件等\nNull 类型：只有一个值 null，不能运算\n\n\n\n常用的全局变量 $_SERVER// 目录根目录\n    $_SERVER[&#39;DOCUMENT_ROOT&#39;]\n// 请求头部\n    $_SERVER[&#39;HTTP_HOST&#39;]\n// 用户 ip 地址\n    $_SERVER[&#39;REMOTE_ADDR&#39;]\n// 服务器的 ip 地址\n    $_SERVER[&#39;SERVER_ADDR&#39;]\n// 服务器主机名称\n    $_SERVER[&#39;SERVER_NAME&#39;]\n// 当前页面的前一页\n    $_SERVER[&#39;HTTP_REFERER&#39;]\n// 判断接收的数据是 post 还是 get\n    $_SERVER[&#39;REQUEST_METHOD&#39;]\n\nPHP 常用的超全局变量// get 传送方式\n    $_GET\n// post 传送方式\n    $_POST\n// 可以接收到 get 和 post 两种方式的值\n    $_REQUEST\n// 引用全局作用域中可用的全部变量\n    $_GLOBALS\n// 上传文件使用\n    $_FILE\n// 系统环境变量\n    $_SERVER\n// 用于会话控制\n    $_COOKIE\n// 用于会话控制\n    $_SESSION\n// 服务器环境变量\n    $_ENV\n\n比较 include 和 require\ninclude 引用不存在的文件会产生一个警告但是程序会继续执行；require 引用不存在的文件会导致一个致命的错误，程序停止执行\ninclude 执行时文件每次都要进行读取；require 文件只处理一次，所以在引用的文件较大时，require 的效率更高\n\n比较 get 和 post 两种传输方式（常规答案）\n数据传输大小： get 传输数据的大小是 2kb，而 post 一般是没有限制的，但是会受内存大小影响，一般通过修改 php.ini 配置文件来修改\n数据传输方式： get 是通过 url 传递参数的，在 url 中可以看到参数；post 是在表单中使用 post 方法提交\n数据安全性：get 参数可见，容易被攻击\n缓存： get 可以被缓存， post 不能被缓存\n\necho、print、print_r 的区别\necho 可以输出一个或者多个变量\nprint 只能打印一个变量\nprint_r 是一个函数，打印的是复合类型的变量，比如 数组、对象\n\n传值赋值和引用赋值的区别\n传值赋值是将变量里的内容赋值一份，被赋值的变量不会被影响\n引用赋值是将两个变量指向同一个内存空间，只要其中一个变量改变就会影响到另一个变量\n\n将 1234567890 改为 1,234,567,890&lt;?php\n    $str = &#39;1234567890&#39;;\n    $strrev = strrev($str);\n    $chunk = chunk_split($strrev, 3, &#39;,&#39;);\n    $result = strrev($chunk);\n    $result = substr($result, 1);\n    echo $result;\n\nsession 和 cookie 的区别\ncookie 的数据存放在客户端，session 的数据存放在服务器\ncookie 安全性较差，别人可以分析放在本地的 cookie 进行 cookie 欺骗（CSRF，跨站伪造请求攻击）\nsession 会在一定时间内保存在服务器上，当大量的 session 存在，会影响服务器的性能\n单个 cookie 保存的数据长度不能超过 4kb ，很多浏览器都限制一个网址最多能保存 20 个 cookie\n\n如何设置 session 的过期时间session_set_cookie_params()\n\nPHP 常见的设计模型\n策略模式\n是对象的行为模式，是对一组算法的封装，动态的选择需要的算法使用\n\n\n工厂模式\n最常用的实例化对象模式，是用工厂的方法代替 new 操作的一种方式\n\n\n单例模式\n保证某个类只有一个实例，而且自动实例化并向整个系统提供这个实例\n只实例化一次，避免大量的 new 操作，消耗系统和内存资源\n饿汉模式：在类初始化就自行实例化\n懒汉模式：只是在第一次调用的时候进行实例化\n\n\n适配器模式\n将各种截然不同的函数接口封装成一个统一的 API\n\n\n注册模式\n解决全局共享和交换对象\n\n\n观察者模式\n当一个对象发生变化时，依赖它的对象都会收到消息，并自动更新（比如 事件）\n\n\n\n数组常用的函数array_merge(); // 合并数组\narray_push(); // 往数组后追加\narray_unique(); // 去重\narray_keys(); // 获取数组的 key 值\narray_values(); // 获取数据的 value 值\narray_filter(); // 去空\nin_array(); // 数组包含\ncount(); // 计算数组的长度\n\n面对对象的特征\n封装：只需要知道这个类是做什么的，不需要关心怎么实现\n继承：子类可以继承父类的属性和方法，也可以重写或者新增属性和方法，增加了代码的可重用\n多态：同一个类的不同对象使用同一个方法可以得到不同的结果，增加了灵活性和重用性\n\n面对对象的五大原则\n单一职责原则：一个类的功能单一\n开放封闭原则：在扩展上是开放的，在更改性能方面是封闭的\n替换原则：子类可以替换父类出现在父类可以出现的地方\n依赖原则：具体依赖抽象，上层依赖下层\n接口隔离原则：模块间要通过接口隔离开，而不是通过具体的类强耦合\n\nPHP7 比 PHP5 性能高\n变量存储字节看小，减少内存占用，提升变量的操作速度\n改善数组结构，数组元素和 hash 映射表分配在同一内存，降低内存占用，提高了 cpu 的缓存命中率\n改进了函数的调用机制，通过优化参数传递的环节，减少了一些指令，提高了执行效率\n\nPHP7 和 PHP5 的区别\n性能提升了 2 倍\n全面一致的支持 64 位\n之前出现的致命错误，现在改为抛出异常\n增加了空结合操作符\n增加了函数返回类型声明\n增加了标量类型声明\n增加了匿名函数\n移除了一些老的不再支持的SPAI（服务器端应用编程端口）和扩展（mysql mssql）\n可以定义常量数组\n\nphp.ini 的优化\n内存分配\nzend opcache 缓存操作码\n设置文件上传大小\n设置进程超时时间\n处理会话（将会话存入缓存中而不是数据库）\n缓冲输出（用最少的块输出最多的数据）\n\n抽象和接口的区别\n接口的访问控制必须是 public，抽象三种都可以\n继承接口用 implement，继承抽象用 extends\n声明接口用 interface，声明抽象用 abstract\n接口没有构造函数\n一个类可以继承多个接口，只能继承一个抽象\n\n抽象\n里面至少有一个抽象方法 abstract\n只声明了方面，没有具体实现\n被继承时，子类必须实现继承的所有方法\n子类的访问控制必须比父类更加宽松\n\n接口\n定义的所有方法必须是公有的\n用 interface 来定义接口，用implement 来继承接口\n实现接口必须实现接口里的所有方法\n可以继承多个接口，用逗号分隔\n\nfinal 关键字\n类声明 final 关键字，不能被继承\n方法声明 final 关键字，不能被重写\n\nyield 生成器及时计算并产出后续值，不占用宝贵的内存，简单的迭代器\n访问修饰符public/protected/private\n\nPHP 常用的魔术常量1. __FILE__ // 完整文件路径或文件名\n2. __LINE__ // 当前行号\n3. __DIR__ // 文件所有目录\n4. __FUNCTION__ // 函数名称\n5. __CLASS__ // 类名称\n6. __METHOD__ // 方法名称\n7. __NAMESPACE__ // 当前命名空间\n\nPHP 常用的魔术方法1. __construct()\n2. __destruct()\n3. __isset()\n4. __toString()\n5. __get()\n6. __set()\n7. __unset()\n8. __clone()\n9. __debugInfo()\n\n单点登录session 共享来实现\n权限系统设计\n用户\n角色\n权限\n用户角色\n角色权限\n\nMySQLSql 语句应该考虑哪些安全性\n防止 sql 注入，对特殊字符进行转义和过滤\n用最小权限原则，最好不用 root 连接数据库\n当 sql 运行出错时，不要把错误信息展示给用户\n\nSql 索引\n普通索引\n唯一索引\n主键索引\n复合索引\n\nMySQL 索引的优缺点\n优点\n加快查询速度\n可以加速表与表之间的连接\n在使用分组和排序进行检索的时候，可以减少查询中分组和排序的时间\n减少服务器对数据的扫描\n帮助服务器避免排序和临时表\n将随机 I/O 变成顺序 I/O\n\n\n缺点\n占用磁盘空间\n对于写的操作，会降低速度\n创建和维护索引要消耗时间，这种时间随着数据量的增加而增加\n\n\n\nMySQL 什么时候会产生临时表\nunion 查询\norder by 和 group by 子句不一样\ndistinct 加上 order by 查询\nfrom 中的子查询\n表连接中，order by 的列不是驱动表中的\n\n什么时候应该创建索引\n经常需要搜索的列上，可以加快搜索的速度\n做为主键的列上\n经常用在 where 子句上的列\n经常用做排序和分组的列\n经常用在连接的列上，主要是一些外键，可以加快连接的速度\n\n什么时候不需要创建索引\n查询中很少使用的列\n只有很少数据值的列\n经常进行增删改的列，频繁更新的列\n数据重复且平均分布的列，比如 男女\n\n什么时候索引失效\n条件中带有 or\nlike 模糊查询中以 % 开头\n如果列是字符串，没有用引号引用起来\n使用函数或者四则运算\n判断索引不是某个值 !=\nnot in 查询\n\nchar 和 varchar 的区别\nchar 是定长，不管存储是否达到设定的值，都按设定的值存储，效率较高\nvarchar 是变长，存储的字符要比 char 长\nchar 的效率比 varchar 要高\n\n优化 SQL 语句\n尽量选择较少的列查询\n在 where 后面频繁使用的字段加上索引\n避免是用 select * 查询\n避免在索引列上做运算，使用 not in 和 &lt;&gt; 等操作\n合理的使用 limit\n合适表分割，在查询较慢的地方使用 explain 分析查询语句\n\nMySQL 中的事务（ACID）\n原子性（A）：一组 sql 要么全部成功要么全部失败\n一致性（C）：一致的从一种状态改变为另一种状态\n隔离型（I）：一个事务未完成之前不会被另一个事务读取\n持久性（D）：一旦食物提交，数据就会永久写入系统\n\nMySQL 优化\n选取合适的字段属性，字段的宽度尽可能的小\n用连接查询来替代子查询\n使用事务\n使用外键\n建立索引\n优化查询语句\n锁定表\n\n数据库的三大范式\n保证每一列都是不可再分的属性值，保证每一列的原子性，减少冗余\n保证每一列都必须依赖主键\n保证每一列都与主键有直接关系，而不是间接关系\n\n数据库内部实现机制\n\n\nMySQL 脏读/虚读/幻读解决方法解决方法：通过事务的隔离级别（读未提交/读已提交/可重复读/串行化）\n\n脏读：指的是一个线程中的事务读取到另一个线程中未提交的数据（读已提交）\n虚读：指的是一个线程中的事务读取到另一个线程中提交的 update 的数据（可重复读/加锁）\n幻读：指的是一个线程中的事务读取到另一个线程中提交的 inster 的数据（串行化）\n\n数据库的存储引擎\nMyISAM\n插入数据快，空间和内存使用比较低\n不支持事务\n数据存储在文件中\n支持表级锁\n\n\nInnoDB\n支持事务/行锁/外键\n数据存储在共享表空间\n支持奔溃后修复\n\n\nMemory\n所有数据在内存中，数据处理速度快\n对表的大小有要求，不能建立太大的表\n安全性不高\n\n\nArchive\n适合查询和存储\n\n\n\n悲观锁和乐观锁\n乐观锁：每次去拿数据都会认为别人不会修改数据，但是在更新数据的时候会判断在此期间有没有更新这个数据，适合多读的场景\n悲观锁：每次去拿数据都会认为别人会修改数据，所以每次都拿数据都会上锁，适合多写的操作\n\n主从复制1. 基本过程\n主库在事务提交时会把数据更作事件记录在二进制文件 binlog 中，主库上的 sync_binlog 参数控制 binlog 日志刷新到磁盘中\n主库推送二进制文件 binlog 到从库的中继日志 relay-log，之后从库根据 relay log 日志做数据变更操作\n\n2. 主要的三个线程\nBinlog dump 线程（主库）\nI/O 线程（从库）\nSQL 线程（从库）\n\n当从库上启动复制，首先创建 I/O 线程连接主库，主库随后创建 Binlog dump 线程读取数据库事件发送给 I/O 线程，I/O 线程读取到事件数据之后更新到从库的中继日志 Relay log 中，之后从库的 SQL 线程读取中继日志中更新的数据库事件并应用\n3. 三种复制方式\n基于 SQL 语句的复制\n 每条修改数据的 SQL 都会保存在 binlog 日志中\n\n基于行的复制\n 每行的数据变化都会记录到 binlog 日志中\n\n混合复制模式\n 基于语句和行混合使用\n\n\n4. 复制的三种常见架构\n一主多从\n 一个主库多个从库，读写分离，主库主要负责写和实时性较高的读的操作，从库主要负责读取的操作\n\n多级复制\n 两个 master，多个 slave，其中一个 master 主要负责推送 binlog 日志到 slave\n 优点：解决了主库的 I/O 负载和网络压力\n 缺点：数据延时比较大（优化：master2 上选择 BLACKHOLE 引擎来降低延时，原理是 BLACKHOLE 表的数据不会写回到磁盘上，永远是空表，只用来记录 bin log 日志）\n\n双主复制\n 两个 master 库，适合 DBA 做维护，master1 和 master2 互为主从，写的操作访问 master1 ，读的操作访问 master1 或者 master2\n\n\n5. 复制类型\n异步复制\n  数据库事务提交之后，在主库写入 bin log 日志就可以成功返回给客户端\n\n半同步复制\n  数据库事务提交之后，bin log 不仅要写在主库上，还要同时向从库推送，等到从库收到 bin log 日志后才会返回成功给客户端，如果从库长时间没有返回，则自动调整为异步复制\n\n\nNginx负载均衡五种策略\n轮询（默认）\n 每个请求按时间顺序逐一分配到不同后端服务器，如果服务器 down掉，能自动剔除\n\n权重（weight）\n 指定轮询的几率，weight 和访问比率成正比\n\nip_hash\n 解决用户登录信息丢失的情况，每次请求都定位到同一个服务器\n\nUrl_hash\n 按 url 的 hash 结果来分配请求，使每个 url 定向到同一个对应的后端服务器\n\n第三方 fair\n 按后端服务器响应时间来分配，响应时间短的优先分配\n\n\n反向代理1. 理解反向代理是指代理服务器接收 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就变现为一个服务器\n2.为什么使用反向代理\n可以起到保护网站安全的作用，因为任何来自 internet 的请求都必须先经过代理服务器\n通过缓存静态资源，加速 web 请求\n实现负载均衡\n\nHTTPurl 访问网站的过程\ndns 解析，将域名解析为 ip 地址\n\ntcp 连接，tcp 的三次握手\n\n由浏览器发起，告诉服务器要开始请求数据了\n\n由服务器发起，告诉了浏览器准备好了接收数据，可以发起请求\n\n由浏览器发起，告诉服务器马上发送数据，准备接收\n\n\n\n发送请求\n\n接收响应\n\n渲染页面\n\n断开连接，tcp 的四次挥手\n\n由浏览器发起，告诉服务器请求报文发送完毕，准备关闭\n\n由服务器发起，告诉浏览器，请求报文接收完毕，准备关闭，你也准备关闭\n\n由服务器发起，告诉浏览器，响应报文发送完毕，你准备关闭\n\n由浏览器发起，告诉服务器，响应报文接收完毕，准备关闭\n\n\n\n\n常见的 http 状态码\n1xx：请求被接收\n2xx：成功\n3xx：重定向\n4xx：客户端错误\n5xx：服务器错误\n\n301:永久重定向\n302:临时重定向\n401:权限不足，请求认证用户身份信息\n403:拒绝访问\n404:无法找到请求的资源\n405:客户端请求中的方法被禁止\n500:服务器内部错误\n501:此请求方法不被服务器支持且无法被处理\n502:网关错误\n503:服务器繁忙\n504:不能及时响应\n\nosi 的七层模型 和 tcp/ip 四层关系\n   \n        OSI 七层网络模型\n        TCP/IP四层概念模型\n        对应网络协议\n    \n    \n        应用层\n        应用层\n        HTTP、TFTP, FTP, NFS, WAIS、SMTP\n    \n    \n        表示层\n        Telnet, Rlogin, SNMP, Gopher\n    \n    \n        会话层\n        SMTP, DNS\n    \n    \n        传输层\n        传输层\n        TCP, UDP\n    \n    \n        网络层\n        网络层\n        IP, ICMP, ARP, RARP, AKP, UUCP\n    \n    \n        数据链路层\n        数据链路层\n        FDDI, Ethernet, Arpanet, PDN, SLIP, PPP\n    \n    \n        物理层\n        IEEE 802.1A, IEEE 802.2到IEEE 802.11\n    \n\n\n跨域怎么出现的，怎么解决跨域出现：浏览器的同源策略，限制了一个源的文件或者脚本如何和另一个源的资源进行交互，如果没有同源策略，容易收到 XSS/CSRF 等攻击\n解决：\n\njsonp，利用 &lt;script&gt; 标签没有跨域限制的漏洞，页面可以动态的得到其他源的 json 数据\n\n优点：兼容性好，可以用于主流浏览器的跨域访问问题\n缺点：仅支持 get 方法；不安全，容易遭受 xss 攻击\n\n\ncors 跨域资源共享，分为简单请求和复杂请求\n\n简单请求\n复杂请求，在正式请求之前，增加一次 http 查询请求\n\n\nnginx 的反向代理\n 配置一个代理服务器做跳板机\n\nnode 中间件代理（两次跨域）\n 实现原理：就是服务器向服务器请求\n\n\nRedisRedis 和 memcached 的区别\nredis 支持更加丰富的数据存储类型（string/hash/list/set/sorted set）；memcached 只支持简单的 key-value 结构\nredis 支持简单的事务\nredis 支持数据持久型，可以将内存中的数据保存在磁盘中\n持久性：\nRDB：在一定周期内，将内存中的数据以快照的形式保存到硬盘的二进制文件\nAOF：redis 将每个收到的写命令都通过 write 函数追加到文件最后，redis 重启会重新执行文件中保存的写命令来在内存中重建整个数据库的内容\n\n\n\n\nredis 只是单核，memcached 是多核\n\n缓存雪崩/穿透\n雪崩：当缓存服务器重启或者是大量缓存在同一时间失效，给后台系统带来很大的压力，导致系统崩溃\n解决：\n当缓存失效时，增加锁来保证某个 key 只有一个线程操作数据库\n分散缓存失效时间\n做二级缓存\n\n\n\n\n穿透：大量请求绕过缓存直接请求数据库\n解决\n对一定不存在的 key 进行过滤，将可能存在 key 放在一个大的 bitmap 中，查询时过滤\n对空值也进行缓存，缓存时间短一点\n\n\n\n\n\n单线程的 redis 为什么这么快\n纯内存操作\n单线程操作，避免了上下文切换\n采用的非阻塞 I/O 多路复用机制\n\nRedis 的数据类型以及每种数据类型的使用场景\nstring：最常规的 set/get 操作，一般做一些复杂的技术功能的缓存\nhash：存放结构化的对象\nlist：可以做简单的消息队列功能，可以做 redis 分页功能（lrange）\nsort：存储的是不重复的值，适合做全局去重的功能\nsorted set：集合中多了个 score 参数，可以做排行榜应用\n\nRedis 的过期策略以及内存淘汰机制过期策略：\n\n定期删除，没一段时间检查是否有过期 key\n惰性删除，使用时用到这个 key 的时候检查，过期就删除\n\n淘汰机制\n\n从已设置过期时间的数据集中挑选最少使用的数据淘汰 -&gt; volatitle-lru\n从已设置过期时间的数据集中挑选即将过期的数据淘汰 -&gt; volatitle-ttl\n从已设置过期时间的数据集中任意选择数据淘汰 -&gt; volatitle-random\n从数据集中挑选最近最少使用的数据淘汰 -&gt; allkeys-lru\n从数据集中中任意淘汰 allkeys-random\n禁止驱逐数据，新写入会报错 no-enviction\n\nother如何处理高并发\n使用缓存\n优化数据库，提高数据使用效率\n负载均衡\n静态页面\n分布式部署，业务分离\n防盗链\n限制大文件下载\ncdn 加速\n\n怎么解决商品超卖和秒杀的问题\n加锁\n队列\n\nAPI 安全接口解决方案\n非对称加密 rsa\n  利用公钥和密钥，公钥传递数据，密钥解密获取数据\n\nMd5 加密\n\n令牌 access_token\n\n\nweb 安全\nXSS 攻击，跨站脚本攻击：往 web 页面插入可以执行的脚本代码，达到盗取用户信息或者侵犯用户隐私的目的\n攻击方式\n非持久型：诱骗点击 url 链接\n持久型：一般是表单提交\n\n\n防范\nweb 渲染的页面必须是来自服务端，做转义\n不要相信前端传递过来的数据，将所有字段转义后处理\n\n\n\n\nCSRF 跨站伪造请求攻击\n攻击方式\n被攻击者登录了网站并保留了 cookie 信息\n访问了危险网站，并受引诱登录了之前的网站\n被攻击者没有做 csrf 防范\n\n\n防范\n正确的使用 get、post请求和cookie\n在非 get 中使用 token加密\n渲染表单加上 csrfToken，后端验证\n\n\n\n\nSQL 注入：没有有效的过滤用户的输入，使攻击者向服务端提交了恶意的 sql 查询代码，导致原 sql 查询逻辑改变\n防范\n数据库最小操作权限\n内容必须转义\n尽量不要使用拼接 sql 语句\n不要将 sql 错误暴露给用户\n\n\n\n\nDDOS 攻击，分布式拒绝服务，使用大量的请求资源导致资源过载，服务不可用\n防范\n网络上做好架构，负载均衡\n限制单个 ip 的访问次数\n关闭不必要的服务\n防火墙\n堆机器\n\n\n\n\ndns 和 http 劫持\ndns：被篡改访问的地址\nhttp：被篡改被访问的内容\n\n\n\n","tags":["面试总结"]}]